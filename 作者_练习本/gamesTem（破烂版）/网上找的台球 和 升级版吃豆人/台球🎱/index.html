<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°çƒæ¸¸æˆ ğŸ±</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(to bottom, #1a2a6c, #b21f1f, #fdbb2d);
            font-family: Arial, sans-serif;
            color: white;
            min-height: 100vh;
        }

        h1 {
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }

        .game-container {
            position: relative;
            margin: 20px 0;
        }

        canvas {
            background-color: #0a5c36;
            border: 10px solid #5d4037;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            width: 800px;
            max-width: 100%;
        }

        button {
            padding: 8px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        .power-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #powerSlider {
            width: 150px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 800px;
            max-width: 100%;
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 10px;
        }

        .instructions {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
            width: 800px;
            max-width: 100%;
        }

        .cue {
            position: absolute;
            pointer-events: none;
            transform-origin: left center;
        }

        #playerTurn {
            font-weight: bold;
            color: #FFD700;
        }
    </style>
</head>
<body>
    <h1>å°çƒæ¸¸æˆ ğŸ±</h1>

    <div class="game-info">
        <div>ç©å®¶1å¾—åˆ†: <span id="player1Score">0</span></div>
        <div>ç©å®¶2å¾—åˆ†: <span id="player2Score">0</span></div>
        <div>å½“å‰å›åˆ: <span id="playerTurn">ç©å®¶1</span></div>
        <div>æ¸¸æˆçŠ¶æ€: <span id="gameState">å‡†å¤‡ä¸­</span></div>
    </div>

    <div class="game-container">
        <canvas id="poolTable" width="800" height="400"></canvas>
    </div>

    <div class="controls">
        <div class="power-container">
            <label for="powerSlider">å‡»çƒåŠ›åº¦:</label>
            <input type="range" id="powerSlider" min="1" max="100" value="50">
            <span id="powerValue">50</span>
        </div>

        <button id="shootBtn">å‡»çƒ</button>
        <button id="newGameBtn">æ–°æ¸¸æˆ</button>
        <button id="toggleGuideBtn">æ˜¾ç¤º/éšè—è¾…åŠ©çº¿</button>
        <button id="changeViewBtn">åˆ‡æ¢è§†è§’</button>
    </div>

    <div class="instructions">
        <h3>æ¸¸æˆè¯´æ˜:</h3>
        <ul>
            <li>ä½¿ç”¨é¼ æ ‡ç§»åŠ¨æ¥ç„å‡†ç™½çƒ</li>
            <li>è°ƒæ•´åŠ›åº¦æ»‘å—æ§åˆ¶å‡»çƒåŠ›é‡</li>
            <li>ç‚¹å‡»"å‡»çƒ"æŒ‰é’®æˆ–æŒ‰ç©ºæ ¼é”®å‡»çƒ</li>
            <li>ç©å®¶1éœ€è¦å‡»æ‰“å•è‰²çƒ(1-7å·)ï¼Œç©å®¶2å‡»æ‰“èŠ±è‰²çƒ(9-15å·)</li>
            <li>8å·çƒéœ€è¦åœ¨æœ€åå‡»æ‰“</li>
            <li>çŠ¯è§„ä¼šå°†ç™½çƒäº¤ç»™å¯¹æ‰‹</li>
        </ul>
    </div>

    <script>
        // æ¸¸æˆå¸¸é‡
        const BALL_RADIUS = 15;
        const WHITE_BALL_START = { x: 200, y: 200 };
        const POCKET_RADIUS = 20;
        const FRICTION = 0.98;
        const MIN_VELOCITY = 0.1;
        const MAX_POWER = 10;

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            balls: [],
            pockets: [],
            cueBall: null,
            player1Score: 0,
            player2Score: 0,
            currentPlayer: 1,
            gamePhase: 'placing', // placing, aiming, moving, gameOver
            player1Type: 'solids', // solids or stripes
            player2Type: 'stripes',
            firstCollision: null,
            foul: false,
            guideVisible: true,
            topDownView: true,
            lastPocketed: null
        };

        // DOMå…ƒç´ 
        const canvas = document.getElementById('poolTable');
        const ctx = canvas.getContext('2d');
        const powerSlider = document.getElementById('powerSlider');
        const powerValue = document.getElementById('powerValue');
        const shootBtn = document.getElementById('shootBtn');
        const newGameBtn = document.getElementById('newGameBtn');
        const toggleGuideBtn = document.getElementById('toggleGuideBtn');
        const changeViewBtn = document.getElementById('changeViewBtn');
        const player1ScoreEl = document.getElementById('player1Score');
        const player2ScoreEl = document.getElementById('player2Score');
        const playerTurnEl = document.getElementById('playerTurn');
        const gameStateEl = document.getElementById('gameState');

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // æ¸…é™¤ç°æœ‰çŠ¶æ€
            gameState.balls = [];
            gameState.pockets = [];
            gameState.player1Score = 0;
            gameState.player2Score = 0;
            gameState.currentPlayer = 1;
            gameState.gamePhase = 'placing';
            gameState.player1Type = 'solids';
            gameState.player2Type = 'stripes';
            gameState.firstCollision = null;
            gameState.foul = false;
            gameState.lastPocketed = null;

            updateScoreDisplay();
            playerTurnEl.textContent = 'ç©å®¶1';
            gameStateEl.textContent = 'æ”¾ç½®ç™½çƒ';

            // åˆ›å»ºçƒè¢‹
            createPockets();

            // åˆ›å»ºç™½çƒ
            gameState.cueBall = {
                x: WHITE_BALL_START.x,
                y: WHITE_BALL_START.y,
                vx: 0,
                vy: 0,
                radius: BALL_RADIUS,
                color: 'white',
                number: 0,
                type: 'cue'
            };

            // åˆ›å»ºå…¶ä»–çƒ
            createBalls();

            // ç»˜åˆ¶åˆå§‹çŠ¶æ€
            draw();
        }

        // åˆ›å»ºçƒè¢‹
        function createPockets() {
            const margin = 20;
            const width = canvas.width - margin * 2;
            const height = canvas.height - margin * 2;

            // å…­ä¸ªçƒè¢‹ä½ç½®
            gameState.pockets = [
                { x: margin, y: margin }, // å·¦ä¸Š
                { x: canvas.width / 2, y: margin - 5 }, // ä¸­ä¸Š
                { x: canvas.width - margin, y: margin }, // å³ä¸Š
                { x: margin, y: canvas.height - margin }, // å·¦ä¸‹
                { x: canvas.width / 2, y: canvas.height - margin + 5 }, // ä¸­ä¸‹
                { x: canvas.width - margin, y: canvas.height - margin } // å³ä¸‹
            ];
        }

        // åˆ›å»ºæ‰€æœ‰çƒ
        function createBalls() {
            // é‡ç½®çƒæ•°ç»„
            gameState.balls = [];

            // ä¸‰è§’å½¢æ’åˆ—çš„çƒ
            const startX = canvas.width - 150;
            const startY = canvas.height / 2;

            // 8å·çƒåœ¨ä¸­å¿ƒ
            const ball8 = {
                x: startX,
                y: startY,
                vx: 0,
                vy: 0,
                radius: BALL_RADIUS,
                color: 'black',
                number: 8,
                type: 'eight'
            };
            gameState.balls.push(ball8);

            // å…¶ä»–çƒçš„æ’åˆ—
            const ballNumbers = [1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15];
            const positions = [
                { row: 0, col: 0 }, // ç¬¬ä¸€æ’
                { row: 1, col: -0.5 }, { row: 1, col: 0.5 }, // ç¬¬äºŒæ’
                { row: 2, col: -1 }, { row: 2, col: 0 }, { row: 2, col: 1 }, // ç¬¬ä¸‰æ’
                { row: 3, col: -1.5 }, { row: 3, col: -0.5 }, { row: 3, col: 0.5 }, { row: 3, col: 1.5 }, // ç¬¬å››æ’
                { row: 4, col: -2 }, { row: 4, col: -1 }, { row: 4, col: 0 }, { row: 4, col: 1 }, { row: 4, col: 2 } // ç¬¬äº”æ’
            ];

            const spacing = BALL_RADIUS * 2.1;

            for (let i = 0; i < positions.length; i++) {
                const pos = positions[i];
                const ballNum = ballNumbers[i];

                const ball = {
                    x: startX + pos.row * spacing * Math.sin(Math.PI/3),
                    y: startY + pos.col * spacing,
                    vx: 0,
                    vy: 0,
                    radius: BALL_RADIUS,
                    color: getBallColor(ballNum),
                    number: ballNum,
                    type: ballNum < 8 ? 'solid' : (ballNum === 8 ? 'eight' : 'stripe')
                };

                gameState.balls.push(ball);
            }
        }

        // è·å–çƒçš„é¢œè‰²
        function getBallColor(number) {
            const colors = {
                1: 'yellow',
                2: 'blue',
                3: 'red',
                4: 'purple',
                5: 'orange',
                6: 'green',
                7: 'maroon',
                8: 'black',
                9: 'yellow',
                10: 'blue',
                11: 'red',
                12: 'purple',
                13: 'orange',
                14: 'green',
                15: 'maroon'
            };

            return colors[number] || 'white';
        }

        // ç»˜åˆ¶æ¸¸æˆ
        function draw() {
            // æ¸…é™¤ç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶å°çƒæ¡Œ
            drawTable();

            // ç»˜åˆ¶çƒè¢‹
            drawPockets();

            // ç»˜åˆ¶æ‰€æœ‰çƒ
            drawBalls();

            // å¦‚æœæ˜¯åœ¨ç„å‡†é˜¶æ®µï¼Œç»˜åˆ¶è¾…åŠ©çº¿
            if (gameState.gamePhase === 'aiming' && gameState.guideVisible) {
                drawAimGuide();
            }

            // å¦‚æœæ˜¯æ”¾ç½®ç™½çƒé˜¶æ®µï¼Œç»˜åˆ¶æ”¾ç½®åŒºåŸŸ
            if (gameState.gamePhase === 'placing') {
                drawPlacementArea();
            }

            // å¦‚æœæ˜¯ä¿¯è§†å›¾ï¼Œç»˜åˆ¶çƒæ†
            if (gameState.topDownView && (gameState.gamePhase === 'aiming' || gameState.gamePhase === 'placing')) {
                drawCue();
            }
        }

        // ç»˜åˆ¶å°çƒæ¡Œ
        function drawTable() {
            // æ¡Œé¢
            ctx.fillStyle = '#0a5c36';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // è¾¹æ¡†
            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // æ ‡è®°ç‚¹
            ctx.fillStyle = 'white';

            // å¼€çƒçº¿ç‚¹
            const spotX = canvas.width / 4;
            const spotY = canvas.height / 2;
            ctx.beginPath();
            ctx.arc(spotX, spotY, 3, 0, Math.PI * 2);
            ctx.fill();

            // ä¸­å¤®ç‚¹
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 3, 0, Math.PI * 2);
            ctx.fill();

            // è„šç‚¹
            const footSpotX = canvas.width * 3/4;
            ctx.beginPath();
            ctx.arc(footSpotX, canvas.height / 2, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // ç»˜åˆ¶çƒè¢‹
        function drawPockets() {
            ctx.fillStyle = 'black';
            gameState.pockets.forEach(pocket => {
                ctx.beginPath();
                ctx.arc(pocket.x, pocket.y, POCKET_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ç»˜åˆ¶æ‰€æœ‰çƒ
        function drawBalls() {
            // ç»˜åˆ¶å…¶ä»–çƒ
            gameState.balls.forEach(ball => {
                drawBall(ball);
            });

            // ç»˜åˆ¶ç™½çƒ
            if (gameState.cueBall) {
                drawBall(gameState.cueBall);
            }
        }

        // ç»˜åˆ¶å•ä¸ªçƒ
        function drawBall(ball) {
    // éªŒè¯å‚æ•°
    const x = Number.isFinite(ball.x) ? ball.x : 0;
    const y = Number.isFinite(ball.y) ? ball.y : 0;
    const radius = Math.max(1, Number.isFinite(ball.radius) ? ball.radius : 15);

    // ç»˜åˆ¶é˜´å½±
    if (gameState.topDownView) {
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.1, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fill();
    }

    // ç»˜åˆ¶çƒä½“
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);

    // åˆ›å»ºæ¸å˜
    try {
        const x0 = x - radius/3;
        const y0 = y - radius/3;
        const r0 = radius/4;

        if (Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(r0)) {
            const gradient = ctx.createRadialGradient(x0, y0, r0, x, y, radius);

            if (ball.color === 'white') {
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(1, '#dddddd');
            } else if (ball.color === 'black') {
                gradient.addColorStop(0, '#666666');
                gradient.addColorStop(1, '#000000');
            } else {
                gradient.addColorStop(0, 'white');
                gradient.addColorStop(0.7, ball.color);
                gradient.addColorStop(1, shadeColor(ball.color, -40));
            }

            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = ball.color;
        }
    } catch (e) {
        console.warn('åˆ›å»ºæ¸å˜å¤±è´¥:', e);
        ctx.fillStyle = ball.color;
    }

    ctx.fill();

            // ç»˜åˆ¶çƒå·
            if (ball.number > 0) {
                ctx.fillStyle = ball.number === 8 ? 'white' : (ball.type === 'stripe' ? 'black' : 'white');
                ctx.font = `${ball.radius * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ball.number.toString(), ball.x, ball.y);
            }
        }

        // ç»˜åˆ¶ç„å‡†è¾…åŠ©çº¿
        function drawAimGuide() {
            if (!gameState.cueBall) return;

            const mousePos = getMousePos(canvas, gameState.lastMousePos);
            if (!mousePos) return;

            const dx = mousePos.x - gameState.cueBall.x;
            const dy = mousePos.y - gameState.cueBall.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            // è¾…åŠ©çº¿
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(gameState.cueBall.x, gameState.cueBall.y);

            // å»¶é•¿çº¿
            const lineLength = Math.max(canvas.width, canvas.height);
            ctx.lineTo(
                gameState.cueBall.x - Math.cos(angle) * lineLength,
                gameState.cueBall.y - Math.sin(angle) * lineLength
            );
            ctx.stroke();

            // åŠ›åº¦æŒ‡ç¤ºå™¨
            const power = powerSlider.value / 100 * MAX_POWER;
            const powerLength = power * 10;

            ctx.strokeStyle = `rgba(255, ${255 - power * 25}, 0, 0.8)`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(gameState.cueBall.x, gameState.cueBall.y);
            ctx.lineTo(
                gameState.cueBall.x - Math.cos(angle) * powerLength,
                gameState.cueBall.y - Math.sin(angle) * powerLength
            );
            ctx.stroke();
        }

        // ç»˜åˆ¶æ”¾ç½®åŒºåŸŸ
        function drawPlacementArea() {
            const headSpotX = canvas.width / 4;
            const headSpotY = canvas.height / 2;
            const radius = canvas.width / 8;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(headSpotX, headSpotY, radius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('åœ¨æ­¤åŒºåŸŸå†…æ”¾ç½®ç™½çƒ', headSpotX, headSpotY + radius + 20);
        }

        // ç»˜åˆ¶çƒæ†
        function drawCue() {
            if (!gameState.cueBall || !gameState.lastMousePos) return;

            const mousePos = getMousePos(canvas, gameState.lastMousePos);
            if (!mousePos) return;

            const dx = mousePos.x - gameState.cueBall.x;
            const dy = mousePos.y - gameState.cueBall.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            const cueLength = 200;
            const cueWidth = 5;
            const tipOffset = 30; // çƒæ†å°–ç«¯ä¸çƒçš„è·ç¦»

            ctx.save();
            ctx.translate(gameState.cueBall.x, gameState.cueBall.y);
            ctx.rotate(angle);

            // çƒæ†æ¸å˜
            const gradient = ctx.createLinearGradient(-cueLength, -cueWidth/2, -cueLength + 50, cueWidth/2);
            gradient.addColorStop(0, '#5d4037');
            gradient.addColorStop(0.5, '#8d6e63');
            gradient.addColorStop(1, '#5d4037');

            ctx.fillStyle = gradient;
            ctx.fillRect(-cueLength - tipOffset, -cueWidth/2, cueLength, cueWidth);

            // çƒæ†å°–ç«¯
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-tipOffset, -cueWidth/2, tipOffset, cueWidth);

            ctx.restore();
        }

       // é¢œè‰²è¾…åŠ©å‡½æ•°
function shadeColor(color, percent) {
    let R = parseInt(color.substring(1,3), 16);
    let G = parseInt(color.substring(3,5), 16);
    let B = parseInt(color.substring(5,7), 16);

    R = parseInt(R * (100 + percent) / 100);
    G = parseInt(G * (100 + percent) / 100);
    B = parseInt(B * (100 + percent) / 100);

    R = (R<255)?R:255;  
    G = (G<255)?G:255;  
    B = (B<255)?B:255;  

    // ä¿®æ­£ï¼šä¸ºæ¯ä¸ªtoString()æ·»åŠ é—­åˆæ‹¬å·
    const RR = ((R.toString(16).length===1)?"0"+R.toString(16):R.toString(16));
    const GG = ((G.toString(16).length===1)?"0"+G.toString(16):G.toString(16));
    const BB = ((B.toString(16).length===1)?"0"+B.toString(16):B.toString(16));

    return "#"+RR+GG+BB;
}

        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update() {
            // å¦‚æœçƒåœ¨ç§»åŠ¨ï¼Œæ›´æ–°ä½ç½®
            if (gameState.gamePhase === 'moving') {
                let allStopped = true;

                // æ›´æ–°ç™½çƒä½ç½®
                if (gameState.cueBall) {
                    updateBallPosition(gameState.cueBall);
                    if (gameState.cueBall.vx !== 0 || gameState.cueBall.vy !== 0) {
                        allStopped = false;
                    }
                }

                // æ›´æ–°å…¶ä»–çƒä½ç½®
                gameState.balls.forEach(ball => {
                    updateBallPosition(ball);
                    if (ball.vx !== 0 || ball.vy !== 0) {
                        allStopped = false;
                    }
                });

                // æ£€æµ‹ç¢°æ’
                detectCollisions();

                // æ£€æµ‹çƒè¢‹
                detectPockets();

                // å¦‚æœæ‰€æœ‰çƒéƒ½åœæ­¢äº†
                if (allStopped) {
                    endTurn();
                }
            }
        }

        // æ›´æ–°çƒçš„ä½ç½®
        function updateBallPosition(ball) {
            // åº”ç”¨æ‘©æ“¦åŠ›
            ball.vx *= FRICTION;
            ball.vy *= FRICTION;

            // å¦‚æœé€Ÿåº¦å¾ˆå°ï¼Œè®¾ä¸º0
            if (Math.abs(ball.vx) < MIN_VELOCITY) ball.vx = 0;
            if (Math.abs(ball.vy) < MIN_VELOCITY) ball.vy = 0;

            // æ›´æ–°ä½ç½®
            ball.x += ball.vx;
            ball.y += ball.vy;

            // è¾¹ç•Œæ£€æµ‹
            const margin = BALL_RADIUS;

            // å·¦è¾¹ç•Œ
            if (ball.x < margin) {
                ball.x = margin;
                ball.vx *= -0.8; // åå¼¹
            }

            // å³è¾¹ç•Œ
            if (ball.x > canvas.width - margin) {
                ball.x = canvas.width - margin;
                ball.vx *= -0.8; // åå¼¹
            }

            // ä¸Šè¾¹ç•Œ
            if (ball.y < margin) {
                ball.y = margin;
                ball.vy *= -0.8; // åå¼¹
            }

            // ä¸‹è¾¹ç•Œ
            if (ball.y > canvas.height - margin) {
                ball.y = canvas.height - margin;
                ball.vy *= -0.8; // åå¼¹
            }
        }

        // æ£€æµ‹ç¢°æ’
        function detectCollisions() {
            // çƒä¸çƒçš„ç¢°æ’
            for (let i = 0; i < gameState.balls.length; i++) {
                for (let j = i + 1; j < gameState.balls.length; j++) {
                    checkBallCollision(gameState.balls[i], gameState.balls[j]);
                }

                if (gameState.cueBall) {
                    checkBallCollision(gameState.balls[i], gameState.cueBall);
                }
            }
        }

        // æ£€æµ‹ä¸¤ä¸ªçƒä¹‹é—´çš„ç¢°æ’
        function checkBallCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // å¦‚æœè·ç¦»å°äºä¸¤çƒåŠå¾„ä¹‹å’Œï¼Œå‘ç”Ÿç¢°æ’
            if (distance < ball1.radius + ball2.radius) {
                // è®°å½•ç¬¬ä¸€æ¬¡ç¢°æ’
                if (gameState.firstCollision === null && gameState.cueBall) {
                    if (ball1 === gameState.cueBall || ball2 === gameState.cueBall) {
                        const otherBall = ball1 === gameState.cueBall ? ball2 : ball1;
                        gameState.firstCollision = otherBall;
                    }
                }

                // è®¡ç®—ç¢°æ’è§’åº¦
                const angle = Math.atan2(dy, dx);

                // è®¡ç®—é€Ÿåº¦åˆ†é‡
                const sin = Math.sin(angle);
                const cos = Math.cos(angle);

                // æ—‹è½¬åæ ‡ç³»
                const x1 = 0;
                const y1 = 0;
                const x2 = dx * cos + dy * sin;
                const y2 = dy * cos - dx * sin;

                // æ—‹è½¬é€Ÿåº¦å‘é‡
                const vx1 = ball1.vx * cos + ball1.vy * sin;
                const vy1 = ball1.vy * cos - ball1.vx * sin;
                const vx2 = ball2.vx * cos + ball2.vy * sin;
                const vy2 = ball2.vy * cos - ball2.vx * sin;

                // ç¢°æ’åçš„é€Ÿåº¦ (1Då¼¹æ€§ç¢°æ’)
                const vx1Final = ((ball1.radius - ball2.radius) * vx1 + 2 * ball2.radius * vx2) / (ball1.radius + ball2.radius);
                const vx2Final = ((ball2.radius - ball1.radius) * vx2 + 2 * ball1.radius * vx1) / (ball1.radius + ball2.radius);

                // é˜²æ­¢çƒé‡å 
                const overlap = (ball1.radius + ball2.radius) - distance;
                const moveX = overlap * cos / 2;
                const moveY = overlap * sin / 2;

                ball1.x -= moveX;
                ball1.y -= moveY;
                ball2.x += moveX;
                ball2.y += moveY;

                // æ›´æ–°é€Ÿåº¦
                ball1.vx = vx1Final * cos - vy1 * sin;
                ball1.vy = vy1 * cos + vx1Final * sin;
                ball2.vx = vx2Final * cos - vy2 * sin;
                ball2.vy = vy2 * cos + vx2Final * sin;
            }
        }

        // æ£€æµ‹çƒè¢‹
        function detectPockets() {
            // æ£€æŸ¥ç™½çƒæ˜¯å¦è¿›è¢‹
            if (gameState.cueBall) {
                for (const pocket of gameState.pockets) {
                    const dx = pocket.x - gameState.cueBall.x;
                    const dy = pocket.y - gameState.cueBall.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < POCKET_RADIUS) {
                        // ç™½çƒè¿›è¢‹
                        handleCueBallPocketed();
                        return;
                    }
                }
            }

            // æ£€æŸ¥å…¶ä»–çƒæ˜¯å¦è¿›è¢‹
            for (let i = gameState.balls.length - 1; i >= 0; i--) {
                const ball = gameState.balls[i];

                for (const pocket of gameState.pockets) {
                    const dx = pocket.x - ball.x;
                    const dy = pocket.y - ball.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < POCKET_RADIUS) {
                        // çƒè¿›è¢‹
                        handleBallPocketed(ball, i);
                        break;
                    }
                }
            }
        }

        // å¤„ç†ç™½çƒè¿›è¢‹
        function handleCueBallPocketed() {
            gameState.foul = true;
            gameState.lastPocketed = gameState.cueBall;
            gameState.cueBall = null;

            // å¦‚æœæ¸¸æˆåˆšå¼€å§‹ï¼Œé‡æ–°æ”¾ç½®ç™½çƒ
            if (gameState.gamePhase === 'moving') {
                gameState.gamePhase = 'placing';
                gameStateEl.textContent = 'æ”¾ç½®ç™½çƒ (çŠ¯è§„)';
            }
        }

        // å¤„ç†å…¶ä»–çƒè¿›è¢‹
        function handleBallPocketed(ball, index) {
            gameState.lastPocketed = ball;

            // ä»æ¸¸æˆä¸­ç§»é™¤çƒ
            gameState.balls.splice(index, 1);

            // å¦‚æœæ˜¯8å·çƒ
            if (ball.number === 8) {
                // æ£€æŸ¥æ˜¯å¦åˆæ³•å‡»æ‰“
                const currentPlayerType = gameState.currentPlayer === 1 ? gameState.player1Type : gameState.player2Type;
                const allPlayerBallsPocketed = gameState.balls.every(b => 
                    b.type !== currentPlayerType && b.type !== 'eight'
                );

                if (allPlayerBallsPocketed) {
                    // åˆæ³•å‡»æ‰“8å·çƒï¼Œå½“å‰ç©å®¶è·èƒœ
                    gameState.gamePhase = 'gameOver';
                    gameStateEl.textContent = `ç©å®¶${gameState.currentPlayer}è·èƒœ!`;
                    alert(`ç©å®¶${gameState.currentPlayer}è·èƒœ!`);
                } else {
                    // éæ³•å‡»æ‰“8å·çƒï¼Œå¯¹æ‰‹è·èƒœ
                    gameState.foul = true;
                    gameState.gamePhase = 'gameOver';
                    const winner = gameState.currentPlayer === 1 ? 2 : 1;
                    gameStateEl.textContent = `ç©å®¶${winner}è·èƒœ!`;
                    alert(`éæ³•å‡»æ‰“8å·çƒ! ç©å®¶${winner}è·èƒœ!`);
                }
                return;
            }

            // æ›´æ–°åˆ†æ•°
            if (gameState.currentPlayer === 1) {
                gameState.player1Score += ball.number;
            } else {
                gameState.player2Score += ball.number;
            }

            updateScoreDisplay();

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç©å®¶çš„çƒ
            const currentPlayerType = gameState.currentPlayer === 1 ? gameState.player1Type : gameState.player2Type;
            const opponentType = gameState.currentPlayer === 1 ? gameState.player2Type : gameState.player1Type;

            if (ball.type === currentPlayerType) {
                // ç©å®¶å‡»æ‰“è‡ªå·±çš„çƒï¼Œåˆæ³•
                gameState.foul = false;
            } else if (ball.type === opponentType) {
                // ç©å®¶å‡»æ‰“å¯¹æ‰‹çš„çƒï¼ŒçŠ¯è§„
                gameState.foul = true;
            }

            // å¦‚æœæ˜¯æ¸¸æˆåˆšå¼€å§‹ï¼Œç¡®å®šç©å®¶çƒç±»å‹
            if (gameState.player1Type === 'solids' && gameState.player2Type === 'stripes') {
                if (ball.type === 'solid') {
                    gameState.player1Type = 'solids';
                    gameState.player2Type = 'stripes';
                } else if (ball.type === 'stripe') {
                    gameState.player1Type = 'stripes';
                    gameState.player2Type = 'solids';
                }
            }
        }

        // ç»“æŸå½“å‰å›åˆ
        function endTurn() {
            gameState.gamePhase = 'aiming';
            gameStateEl.textContent = 'ç„å‡†ä¸­';

            // æ£€æŸ¥çŠ¯è§„
            if (gameState.foul) {
                // åˆ‡æ¢ç©å®¶
                gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
                playerTurnEl.textContent = `ç©å®¶${gameState.currentPlayer} (çŠ¯è§„)`;

                // å¦‚æœç™½çƒè¿›è¢‹ï¼Œéœ€è¦æ”¾ç½®
                if (!gameState.cueBall) {
                    gameState.gamePhase = 'placing';
                    gameStateEl.textContent = 'æ”¾ç½®ç™½çƒ (çŠ¯è§„)';
                }
            } else {
                // æ£€æŸ¥æ˜¯å¦æœ‰åˆæ³•è¿›çƒ
                if (gameState.lastPocketed && 
                    ((gameState.currentPlayer === 1 && gameState.lastPocketed.type === gameState.player1Type) || 
                     (gameState.currentPlayer === 2 && gameState.lastPocketed.type === gameState.player2Type))) {
                    // ç©å®¶ç»§ç»­å‡»çƒ
                    playerTurnEl.textContent = `ç©å®¶${gameState.currentPlayer} (ç»§ç»­)`;
                } else {
                    // åˆ‡æ¢ç©å®¶
                    gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
                    playerTurnEl.textContent = `ç©å®¶${gameState.currentPlayer}`;
                }
            }

            // é‡ç½®çŠ¶æ€
            gameState.firstCollision = null;
            gameState.foul = false;
            gameState.lastPocketed = null;
        }

        // å‡»çƒ
        function shoot() {
            if (gameState.gamePhase !== 'aiming' || !gameState.cueBall || !gameState.lastMousePos) return;

            const mousePos = getMousePos(canvas, gameState.lastMousePos);
            if (!mousePos) return;

            const dx = gameState.cueBall.x - mousePos.x;
            const dy = gameState.cueBall.y - mousePos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // è®¡ç®—åŠ›åº¦
            const power = powerSlider.value / 100 * MAX_POWER;

            // è®¾ç½®ç™½çƒé€Ÿåº¦
            gameState.cueBall.vx = (dx / distance) * power;
            gameState.cueBall.vy = (dy / distance) * power;

            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            gameState.gamePhase = 'moving';
            gameStateEl.textContent = 'çƒç§»åŠ¨ä¸­';
        }

        // æ”¾ç½®ç™½çƒ
        function placeCueBall(x, y) {
            if (gameState.gamePhase !== 'placing') return;

            // æ£€æŸ¥æ˜¯å¦åœ¨æ”¾ç½®åŒºåŸŸå†…
            const headSpotX = canvas.width / 4;
            const headSpotY = canvas.height / 2;
            const radius = canvas.width / 8;

            const dx = x - headSpotX;
            const dy = y - headSpotY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > radius) return;

            // æ”¾ç½®ç™½çƒ
            if (!gameState.cueBall) {
                gameState.cueBall = {
                    x: x,
                    y: y,
                    vx: 0,
                    vy: 0,
                    radius: BALL_RADIUS,
                    color: 'white',
                    number: 0,
                    type: 'cue'
                };
            } else {
                gameState.cueBall.x = x;
                gameState.cueBall.y = y;
                gameState.cueBall.vx = 0;
                gameState.cueBall.vy = 0;
            }

            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            gameState.gamePhase = 'aiming';
            gameStateEl.textContent = 'ç„å‡†ä¸­';
        }

        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        function updateScoreDisplay() {
            player1ScoreEl.textContent = gameState.player1Score;
            player2ScoreEl.textContent = gameState.player2Score;
        }

        // è·å–é¼ æ ‡ä½ç½®
        function getMousePos(canvas, evt) {
            if (!evt) return null;

            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        // äº‹ä»¶ç›‘å¬å™¨
        canvas.addEventListener('mousemove', (e) => {
            gameState.lastMousePos = e;
        });

        canvas.addEventListener('click', (e) => {
            const mousePos = getMousePos(canvas, e);
            if (!mousePos) return;

            if (gameState.gamePhase === 'placing') {
                placeCueBall(mousePos.x, mousePos.y);
            }
        });

        shootBtn.addEventListener('click', shoot);

        newGameBtn.addEventListener('click', initGame);

        toggleGuideBtn.addEventListener('click', () => {
            gameState.guideVisible = !gameState.guideVisible;
        });

        changeViewBtn.addEventListener('click', () => {
            gameState.topDownView = !gameState.topDownView;
        });

        powerSlider.addEventListener('input', () => {
            powerValue.textContent = powerSlider.value;
        });

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameState.gamePhase === 'aiming') {
                shoot();
                e.preventDefault();
            }
        });

        // åˆå§‹åŒ–æ¸¸æˆå¹¶å¼€å§‹æ¸¸æˆå¾ªç¯
        initGame();
        gameLoop();
    </script>
</body>
</html>